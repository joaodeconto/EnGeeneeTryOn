<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Smile Detection</title>
  <style>
    video, canvas {
      position: absolute;
      left: 0;
      top: 0;
      transform: scaleX(-1);
    }
    #status {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 18px;
      font-family: sans-serif;
    }
  </style>
</head>
<body>
  <video id="inputVideo" autoplay playsinline width="640" height="480"></video>
  <canvas id="outputCanvas" width="640" height="480"></canvas>
  <div id="status">ðŸ˜Š Waiting for smile...</div>

  <!-- Mediapipe Scripts -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

  <script>
    const videoElement = document.getElementById('inputVideo');
    const canvasElement = document.getElementById('outputCanvas');
    const canvasCtx = canvasElement.getContext('2d');
    const statusEl = document.getElementById('status');

    const smileHistory = [];
    const historySize = 5;
    let smileStartTime = null;
    let smileDetected = false;
    const SMILE_MIN_DURATION = 300; // ms

    function isPositiveReaction(landmarks) {
      const leftCorner = landmarks[61];
      const rightCorner = landmarks[291];
      const upperLip = landmarks[13];
      const lowerLip = landmarks[14];
      const faceWidth = Math.abs(landmarks[234].x - landmarks[454].x); // cheek to cheek

      const mouthHeight = Math.abs(lowerLip.y - upperLip.y);
      const mouthWidth = Math.abs(rightCorner.x - leftCorner.x);

      const normalizedMouthHeight = mouthHeight / faceWidth;
      const normalizedMouthWidth = mouthWidth / faceWidth;

      const leftSmileCurve = upperLip.y - leftCorner.y;
      const rightSmileCurve = upperLip.y - rightCorner.y;
      const smileCurveAvg = (leftSmileCurve + rightSmileCurve) / 2;

      // Smooth smile curve
      smileHistory.push(smileCurveAvg);
      if (smileHistory.length > historySize) smileHistory.shift();
      const avgSmileCurve = smileHistory.reduce((a, b) => a + b, 0) / smileHistory.length;

      // âœ… Balanced thresholds
      const smileCurveThreshold = 0.0001;     // gentle smile
      const laughHeightThreshold = 0.09;      // open mouth
      const laughWidthThreshold = 0.01;       // wide mouth

      const isSmileOnly = avgSmileCurve > smileCurveThreshold;
      const isLaugh = isSmileOnly &&
                      normalizedMouthHeight > laughHeightThreshold &&
                      normalizedMouthWidth > laughWidthThreshold;

      // We return true if either gentle smile or full laugh
      return isSmileOnly || isLaugh;
    }
    function handleSmile(isSmilingNow) {
      const now = Date.now();

      if (isSmilingNow) {
        if (!smileStartTime) {
          smileStartTime = now;
        } else if (!smileDetected && now - smileStartTime > SMILE_MIN_DURATION) {
          smileDetected = true;
          console.log("âœ… Confirmed Smile");
          statusEl.textContent = "ðŸ˜„ Smiling!";
        }
      } else {
        smileStartTime = null;
        smileDetected = false;
        statusEl.textContent = "ðŸ˜Š Waiting for smile...";
      }
    }

    const faceMesh = new FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });

    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    faceMesh.onResults((results) => {
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

      if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
        const landmarks = results.multiFaceLandmarks[0];

        drawConnectors(canvasCtx, landmarks, FACEMESH_LIPS, {
          color: '#00FF00',
          lineWidth: 2
        });

        const smiling = isPositiveReaction(landmarks);
        handleSmile(smiling);
      }

      canvasCtx.restore();
    });

    const camera = new Camera(videoElement, {
      onFrame: async () => {
        await faceMesh.send({ image: videoElement });
      },
      width: 640,
      height: 480
    });

    camera.start();
  </script>
</body>
</html>
